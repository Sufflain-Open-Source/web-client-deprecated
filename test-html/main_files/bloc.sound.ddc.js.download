define(['dart_sdk'], (function load__packages__bloc__bloc(dart_sdk) {
  'use strict';
  const core = dart_sdk.core;
  const async = dart_sdk.async;
  const dart = dart_sdk.dart;
  const dartx = dart_sdk.dartx;
  var transition = Object.create(dart.library);
  var bloc = Object.create(dart.library);
  var bloc_observer = Object.create(dart.library);
  var bloc$ = Object.create(dart.library);
  var $runtimeType = dartx.runtimeType;
  var $hashCode = dartx.hashCode;
  dart._checkModuleNullSafetyMode(true);
  var T = {
    VoidToNever: () => (T.VoidToNever = dart.constFn(dart.fnType(dart.Never, [])))()
  };
  const CT = Object.create({
    _: () => (C, CT)
  });
  dart.defineLazy(CT, {
    get C0() {
      return C[0] = dart.const({
        __proto__: core._StringStackTrace.prototype,
        [_StringStackTrace__stackTrace]: ""
      });
    }
  }, false);
  var C = [void 0];
  var I = [
    "package:bloc/src/transition.dart",
    "package:bloc/src/bloc_observer.dart",
    "package:bloc/src/bloc.dart",
    "org-dartlang-app:///packages/bloc/src/bloc.dart"
  ];
  var currentState$ = dart.privateName(transition, "Change.currentState");
  var nextState$ = dart.privateName(transition, "Change.nextState");
  const _is_Change_default = Symbol('_is_Change_default');
  transition.Change$ = dart.generic(State => {
    var __t$ChangeOfState = () => (__t$ChangeOfState = dart.constFn(transition.Change$(State)))();
    class Change extends core.Object {
      get currentState() {
        return this[currentState$];
      }
      set currentState(value) {
        super.currentState = value;
      }
      get nextState() {
        return this[nextState$];
      }
      set nextState(value) {
        super.nextState = value;
      }
      _equals(other) {
        if (other == null) return false;
        return this === other || __t$ChangeOfState().is(other) && this[$runtimeType]._equals(other[$runtimeType]) && dart.equals(this.currentState, other.currentState) && dart.equals(this.nextState, other.nextState);
      }
      get hashCode() {
        return (dart.hashCode(this.currentState) ^ dart.hashCode(this.nextState)) >>> 0;
      }
      toString() {
        return "Change { currentState: " + dart.str(this.currentState) + ", nextState: " + dart.str(this.nextState) + " }";
      }
    }
    (Change.new = function(opts) {
      let currentState = opts && 'currentState' in opts ? opts.currentState : null;
      let nextState = opts && 'nextState' in opts ? opts.nextState : null;
      this[currentState$] = currentState;
      this[nextState$] = nextState;
      ;
    }).prototype = Change.prototype;
    dart.addTypeTests(Change);
    Change.prototype[_is_Change_default] = true;
    dart.addTypeCaches(Change);
    dart.setLibraryUri(Change, I[0]);
    dart.setFieldSignature(Change, () => ({
      __proto__: dart.getFields(Change.__proto__),
      currentState: dart.finalFieldType(State),
      nextState: dart.finalFieldType(State)
    }));
    dart.defineExtensionMethods(Change, ['_equals', 'toString']);
    dart.defineExtensionAccessors(Change, ['hashCode']);
    return Change;
  });
  transition.Change = transition.Change$();
  dart.addTypeTests(transition.Change, _is_Change_default);
  var event$ = dart.privateName(transition, "Transition.event");
  const _is_Transition_default = Symbol('_is_Transition_default');
  transition.Transition$ = dart.generic((Event, State) => {
    var __t$TransitionOfEvent$State = () => (__t$TransitionOfEvent$State = dart.constFn(transition.Transition$(Event, State)))();
    class Transition extends transition.Change$(State) {
      get event() {
        return this[event$];
      }
      set event(value) {
        super.event = value;
      }
      _equals(other) {
        if (other == null) return false;
        return this === other || __t$TransitionOfEvent$State().is(other) && this[$runtimeType]._equals(other[$runtimeType]) && dart.equals(this.currentState, other.currentState) && dart.equals(this.event, other.event) && dart.equals(this.nextState, other.nextState);
      }
      get hashCode() {
        return (dart.hashCode(this.currentState) ^ dart.hashCode(this.event) ^ dart.hashCode(this.nextState)) >>> 0;
      }
      toString() {
        return "Transition { currentState: " + dart.str(this.currentState) + ", event: " + dart.str(this.event) + ", nextState: " + dart.str(this.nextState) + " }";
      }
    }
    (Transition.new = function(opts) {
      let currentState = opts && 'currentState' in opts ? opts.currentState : null;
      let event = opts && 'event' in opts ? opts.event : null;
      let nextState = opts && 'nextState' in opts ? opts.nextState : null;
      this[event$] = event;
      Transition.__proto__.new.call(this, {currentState: currentState, nextState: nextState});
      ;
    }).prototype = Transition.prototype;
    dart.addTypeTests(Transition);
    Transition.prototype[_is_Transition_default] = true;
    dart.addTypeCaches(Transition);
    dart.setLibraryUri(Transition, I[0]);
    dart.setFieldSignature(Transition, () => ({
      __proto__: dart.getFields(Transition.__proto__),
      event: dart.finalFieldType(Event)
    }));
    dart.defineExtensionMethods(Transition, ['_equals', 'toString']);
    dart.defineExtensionAccessors(Transition, ['hashCode']);
    return Transition;
  });
  transition.Transition = transition.Transition$();
  dart.addTypeTests(transition.Transition, _is_Transition_default);
  bloc_observer.BlocObserver = class BlocObserver extends core.Object {
    onCreate(bloc) {
    }
    onEvent(bloc, event) {
    }
    onChange(bloc, change) {
    }
    onTransition(bloc, transition) {
    }
    onError(bloc, error, stackTrace) {
    }
    onClose(bloc) {
    }
  };
  (bloc_observer.BlocObserver.new = function() {
    ;
  }).prototype = bloc_observer.BlocObserver.prototype;
  dart.addTypeTests(bloc_observer.BlocObserver);
  dart.addTypeCaches(bloc_observer.BlocObserver);
  dart.setMethodSignature(bloc_observer.BlocObserver, () => ({
    __proto__: dart.getMethods(bloc_observer.BlocObserver.__proto__),
    onCreate: dart.fnType(dart.void, [bloc$.BlocBase]),
    onEvent: dart.fnType(dart.void, [bloc$.Bloc, dart.nullable(core.Object)]),
    onChange: dart.fnType(dart.void, [bloc$.BlocBase, transition.Change]),
    onTransition: dart.fnType(dart.void, [bloc$.Bloc, transition.Transition]),
    onError: dart.fnType(dart.void, [bloc$.BlocBase, core.Object, core.StackTrace]),
    onClose: dart.fnType(dart.void, [bloc$.BlocBase])
  }));
  dart.setLibraryUri(bloc_observer.BlocObserver, I[1]);
  var bloc$0 = dart.privateName(bloc$, "BlocUnhandledErrorException.bloc");
  var error$ = dart.privateName(bloc$, "BlocUnhandledErrorException.error");
  var stackTrace$ = dart.privateName(bloc$, "BlocUnhandledErrorException.stackTrace");
  var _StringStackTrace__stackTrace = dart.privateName(core, "_StringStackTrace._stackTrace");
  bloc$.BlocUnhandledErrorException = class BlocUnhandledErrorException extends core.Object {
    get bloc() {
      return this[bloc$0];
    }
    set bloc(value) {
      super.bloc = value;
    }
    get error() {
      return this[error$];
    }
    set error(value) {
      super.error = value;
    }
    get stackTrace() {
      return this[stackTrace$];
    }
    set stackTrace(value) {
      super.stackTrace = value;
    }
    toString() {
      return "Unhandled error " + dart.str(this.error) + " occurred in " + dart.str(this.bloc) + ".\n" + dart.str(this.stackTrace);
    }
  };
  (bloc$.BlocUnhandledErrorException.new = function(bloc, error, stackTrace = C[0] || CT.C0) {
    this[bloc$0] = bloc;
    this[error$] = error;
    this[stackTrace$] = stackTrace;
    ;
  }).prototype = bloc$.BlocUnhandledErrorException.prototype;
  dart.addTypeTests(bloc$.BlocUnhandledErrorException);
  dart.addTypeCaches(bloc$.BlocUnhandledErrorException);
  bloc$.BlocUnhandledErrorException[dart.implements] = () => [core.Exception];
  dart.setLibraryUri(bloc$.BlocUnhandledErrorException, I[2]);
  dart.setFieldSignature(bloc$.BlocUnhandledErrorException, () => ({
    __proto__: dart.getFields(bloc$.BlocUnhandledErrorException.__proto__),
    bloc: dart.finalFieldType(bloc$.BlocBase),
    error: dart.finalFieldType(core.Object),
    stackTrace: dart.finalFieldType(core.StackTrace)
  }));
  dart.defineExtensionMethods(bloc$.BlocUnhandledErrorException, ['toString']);
  var _transitionSubscription = dart.privateName(bloc$, "_transitionSubscription");
  var _eventController = dart.privateName(bloc$, "_eventController");
  var _bindEventsToStates = dart.privateName(bloc$, "_bindEventsToStates");
  var _emitted = dart.privateName(bloc$, "_emitted");
  var __stateController = dart.privateName(bloc$, "__stateController");
  var _state$ = dart.privateName(bloc$, "_state");
  var _stateController = dart.privateName(bloc$, "_stateController");
  const _is_BlocBase_default = Symbol('_is_BlocBase_default');
  bloc$.BlocBase$ = dart.generic(State => {
    var __t$StreamControllerOfState = () => (__t$StreamControllerOfState = dart.constFn(async.StreamController$(State)))();
    var __t$ChangeOfState = () => (__t$ChangeOfState = dart.constFn(transition.Change$(State)))();
    class BlocBase extends core.Object {
      get [_stateController]() {
        let t2;
        t2 = this[__stateController];
        return t2 == null ? this[__stateController] = __t$StreamControllerOfState().broadcast() : t2;
      }
      get state() {
        return this[_state$];
      }
      get stream() {
        return this[_stateController].stream;
      }
      get isClosed() {
        return this[_stateController].isClosed;
      }
      listen(onData, opts) {
        let onError = opts && 'onError' in opts ? opts.onError : null;
        let onDone = opts && 'onDone' in opts ? opts.onDone : null;
        let cancelOnError = opts && 'cancelOnError' in opts ? opts.cancelOnError : null;
        return this.stream.listen(onData, {onError: onError, onDone: onDone, cancelOnError: cancelOnError});
      }
      emit(state) {
        State.as(state);
        if (this[_stateController].isClosed) return;
        if (dart.equals(state, this[_state$]) && this[_emitted]) return;
        this.onChange(new (__t$ChangeOfState()).new({currentState: this.state, nextState: state}));
        this[_state$] = state;
        this[_stateController].add(this[_state$]);
        this[_emitted] = true;
      }
      onChange(change) {
        __t$ChangeOfState().as(change);
        bloc$.Bloc.observer.onChange(this, change);
      }
      addError(error, stackTrace = null) {
        let t2;
        this.onError(error, (t2 = stackTrace, t2 == null ? core.StackTrace.current : t2));
      }
      onError(error, stackTrace) {
        bloc$.Bloc.observer.onError(this, error, stackTrace);
        if (!dart.dtest(dart.fn(() => {
          dart.throw(new bloc$.BlocUnhandledErrorException.new(this, error, stackTrace));
        }, T.VoidToNever())())) dart.assertFailed(null, I[3], 391, 12, "() {\n      throw BlocUnhandledErrorException(this, error, stackTrace);\n    }()");
      }
      close() {
        return async.async(dart.void, (function* close() {
          bloc$.Bloc.observer.onClose(this);
          yield this[_stateController].close();
        }).bind(this));
      }
    }
    (BlocBase.new = function(_state) {
      this[__stateController] = null;
      this[_emitted] = false;
      this[_state$] = _state;
      bloc$.Bloc.observer.onCreate(this);
    }).prototype = BlocBase.prototype;
    dart.addTypeTests(BlocBase);
    BlocBase.prototype[_is_BlocBase_default] = true;
    dart.addTypeCaches(BlocBase);
    dart.setMethodSignature(BlocBase, () => ({
      __proto__: dart.getMethods(BlocBase.__proto__),
      listen: dart.fnType(async.StreamSubscription$(State), [dart.nullable(dart.fnType(dart.void, [State]))], {cancelOnError: dart.nullable(core.bool), onDone: dart.nullable(dart.fnType(dart.void, [])), onError: dart.nullable(core.Function)}, {}),
      emit: dart.fnType(dart.void, [dart.nullable(core.Object)]),
      onChange: dart.fnType(dart.void, [dart.nullable(core.Object)]),
      addError: dart.fnType(dart.void, [core.Object], [dart.nullable(core.StackTrace)]),
      onError: dart.fnType(dart.void, [core.Object, core.StackTrace]),
      close: dart.fnType(async.Future$(dart.void), [])
    }));
    dart.setGetterSignature(BlocBase, () => ({
      __proto__: dart.getGetters(BlocBase.__proto__),
      [_stateController]: async.StreamController$(State),
      state: State,
      stream: async.Stream$(State),
      isClosed: core.bool
    }));
    dart.setLibraryUri(BlocBase, I[2]);
    dart.setFieldSignature(BlocBase, () => ({
      __proto__: dart.getFields(BlocBase.__proto__),
      [__stateController]: dart.fieldType(dart.nullable(async.StreamController$(State))),
      [_state$]: dart.fieldType(State),
      [_emitted]: dart.fieldType(core.bool)
    }));
    return BlocBase;
  });
  bloc$.BlocBase = bloc$.BlocBase$();
  dart.addTypeTests(bloc$.BlocBase, _is_BlocBase_default);
  const _is_Bloc_default = Symbol('_is_Bloc_default');
  bloc$.Bloc$ = dart.generic((Event, State) => {
    var __t$StreamControllerOfEvent = () => (__t$StreamControllerOfEvent = dart.constFn(async.StreamController$(Event)))();
    var __t$StreamOfEvent = () => (__t$StreamOfEvent = dart.constFn(async.Stream$(Event)))();
    var __t$TransitionOfEvent$State = () => (__t$TransitionOfEvent$State = dart.constFn(transition.Transition$(Event, State)))();
    var __t$StreamOfTransitionOfEvent$State = () => (__t$StreamOfTransitionOfEvent$State = dart.constFn(async.Stream$(__t$TransitionOfEvent$State())))();
    var __t$EventToStreamOfTransitionOfEvent$State = () => (__t$EventToStreamOfTransitionOfEvent$State = dart.constFn(dart.fnType(__t$StreamOfTransitionOfEvent$State(), [Event])))();
    var __t$StateToTransitionOfEvent$State = () => (__t$StateToTransitionOfEvent$State = dart.constFn(dart.fnType(__t$TransitionOfEvent$State(), [State])))();
    var __t$TransitionOfEvent$StateTovoid = () => (__t$TransitionOfEvent$StateTovoid = dart.constFn(dart.fnType(dart.void, [__t$TransitionOfEvent$State()])))();
    const close = Symbol("close");
    class Bloc extends bloc$.BlocBase$(State) {
      add(event) {
        Event.as(event);
        if (this[_eventController].isClosed) return;
        try {
          this.onEvent(event);
          this[_eventController].add(event);
        } catch (e) {
          let error = dart.getThrown(e);
          let stackTrace = dart.stackTrace(e);
          if (core.Object.is(error)) {
            this.onError(error, stackTrace);
          } else
            throw e;
        }
      }
      onEvent(event) {
        Event.as(event);
        bloc$.Bloc.observer.onEvent(this, event);
      }
      transformEvents(events, transitionFn) {
        __t$StreamOfEvent().as(events);
        __t$EventToStreamOfTransitionOfEvent$State().as(transitionFn);
        return events.asyncExpand(__t$TransitionOfEvent$State(), transitionFn);
      }
      emit(state) {
        State.as(state);
        return super.emit(state);
      }
      onTransition(transition) {
        __t$TransitionOfEvent$State().as(transition);
        bloc$.Bloc.observer.onTransition(this, transition);
      }
      transformTransitions(transitions) {
        __t$StreamOfTransitionOfEvent$State().as(transitions);
        return transitions;
      }
      close() {
        return async.async(dart.void, (function* close$() {
          let t1;
          yield this[_eventController].close();
          yield (t1 = this[_transitionSubscription], t1 == null ? null : t1.cancel());
          return this[close]();
        }).bind(this));
      }
      [_bindEventsToStates]() {
        this[_transitionSubscription] = this.transformTransitions(this.transformEvents(this[_eventController].stream, dart.fn(event => this.mapEventToState(event).map(__t$TransitionOfEvent$State(), dart.fn(nextState => new (__t$TransitionOfEvent$State()).new({currentState: this.state, event: event, nextState: nextState}), __t$StateToTransitionOfEvent$State())), __t$EventToStreamOfTransitionOfEvent$State()))).listen(dart.fn(transition => {
          if (dart.equals(transition.nextState, this.state) && this[_emitted]) return;
          try {
            this.onTransition(transition);
            this.emit(transition.nextState);
          } catch (e) {
            let error = dart.getThrown(e);
            let stackTrace = dart.stackTrace(e);
            if (core.Object.is(error)) {
              this.onError(error, stackTrace);
            } else
              throw e;
          }
        }, __t$TransitionOfEvent$StateTovoid()), {onError: dart.bind(this, 'onError')});
      }
      [close]() {
        return super.close();
      }
    }
    (Bloc.new = function(initialState) {
      this[_transitionSubscription] = null;
      this[_eventController] = __t$StreamControllerOfEvent().broadcast();
      Bloc.__proto__.new.call(this, initialState);
      this[_bindEventsToStates]();
    }).prototype = Bloc.prototype;
    dart.addTypeTests(Bloc);
    Bloc.prototype[_is_Bloc_default] = true;
    dart.addTypeCaches(Bloc);
    dart.setMethodSignature(Bloc, () => ({
      __proto__: dart.getMethods(Bloc.__proto__),
      add: dart.fnType(dart.void, [dart.nullable(core.Object)]),
      onEvent: dart.fnType(dart.void, [dart.nullable(core.Object)]),
      transformEvents: dart.fnType(async.Stream$(transition.Transition$(Event, State)), [dart.nullable(core.Object), dart.nullable(core.Object)]),
      onTransition: dart.fnType(dart.void, [dart.nullable(core.Object)]),
      transformTransitions: dart.fnType(async.Stream$(transition.Transition$(Event, State)), [dart.nullable(core.Object)]),
      [_bindEventsToStates]: dart.fnType(dart.void, [])
    }));
    dart.setLibraryUri(Bloc, I[2]);
    dart.setFieldSignature(Bloc, () => ({
      __proto__: dart.getFields(Bloc.__proto__),
      [_transitionSubscription]: dart.fieldType(dart.nullable(async.StreamSubscription$(transition.Transition$(Event, State)))),
      [_eventController]: dart.finalFieldType(async.StreamController$(Event))
    }));
    return Bloc;
  });
  bloc$.Bloc = bloc$.Bloc$();
  dart.defineLazy(bloc$.Bloc, {
    /*bloc$.Bloc.observer*/get observer() {
      return new bloc_observer.BlocObserver.new();
    },
    set observer(_) {}
  }, false);
  dart.addTypeTests(bloc$.Bloc, _is_Bloc_default);
  const _is_Cubit_default = Symbol('_is_Cubit_default');
  bloc$.Cubit$ = dart.generic(State => {
    class Cubit extends bloc$.BlocBase$(State) {}
    (Cubit.new = function(initialState) {
      Cubit.__proto__.new.call(this, initialState);
      ;
    }).prototype = Cubit.prototype;
    dart.addTypeTests(Cubit);
    Cubit.prototype[_is_Cubit_default] = true;
    dart.addTypeCaches(Cubit);
    dart.setLibraryUri(Cubit, I[2]);
    return Cubit;
  });
  bloc$.Cubit = bloc$.Cubit$();
  dart.addTypeTests(bloc$.Cubit, _is_Cubit_default);
  dart.trackLibraries("packages/bloc/bloc", {
    "package:bloc/src/transition.dart": transition,
    "package:bloc/bloc.dart": bloc,
    "package:bloc/src/bloc_observer.dart": bloc_observer,
    "package:bloc/src/bloc.dart": bloc$
  }, {
  }, '{"version":3,"sourceRoot":"","sources":["src/transition.dart","src/bloc_observer.dart","src/bloc.dart"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MAYc;;;;;;MAGA;;;;;;cAGY;;AACpB,cAAA,AAAU,AAAa,UAAP,KAAK,IACf,uBAAN,KAAK,KACD,AAAY,2BAAG,AAAM,KAAD,mBACP,YAAb,mBAAgB,AAAM,KAAD,kBACX,YAAV,gBAAa,AAAM,KAAD;MAAU;;AAGhB,cAAsB,EAAT,cAAb,qBAAkC,cAAV;MAAkB;;AAI5D,cAAO,AAA+D,sCAAtC,qBAAY,2BAAc,kBAAS;MACrE;;;UAtB4B;UAA4B;MAA5B;MAA4B;;IAAW;;;;;;;;;;;;;;;;;;;;;MAuCvD;;;;;;cAGY;;AACpB,cAAA,AAAU,AAAa,UAAP,KAAK,IACf,iCAAN,KAAK,KACD,AAAY,2BAAG,AAAM,KAAD,mBACP,YAAb,mBAAgB,AAAM,KAAD,kBACf,YAAN,YAAS,AAAM,KAAD,WACJ,YAAV,gBAAa,AAAM,KAAD;MAAU;;AAIlC,cAA8C,EAA1B,AAAS,cAAtB,qBAA8B,cAAN,cAA2B,cAAV;MAClD;;AAIE,cAAO,AAAsF,0CAAvD,qBAAY,uBAAU,cAAK,2BAAc,kBAAS;MAC1F;;;UAzBiB;UACD;UACC;MADD;AAEX,yDAAoB,YAAY,aAAa,SAAS;;IAAC;;;;;;;;;;;;;;;;aClCrC;IAAO;YAMZ,MAAc;IAAQ;aAOjB,MAAa;IAAS;iBAStB,MAAiB;IAAa;YAO/B,MAAa,OAAkB;IAAa;YAQ5C;IAAO;;;;EAC/B;;;;;;;;;;;;;;;;;;ICzBiB;;;;;;IAGF;;;;;;IAII;;;;;;;AAIf,YAAO,+BAAkB,cAAK,2BAAc,aAAI,iBAC1C;IACR;;oDAnBO,MACA,OACA;IAFA;IACA;IACA;;EACL;;;;;;;;;;;;;;;;;;;;;;;;;;AAmQA,aAAO;cAAkB,cAAlB,0BAAsB;MAC/B;;AAOmB;MAAM;;AAGG,cAAA,AAAiB;MAAM;;AAM9B,cAAA,AAAiB;MAAQ;aAUtB;YACZ;YACO;YACX;AAEN,cAAO,AAAO,oBACZ,MAAM,YACG,OAAO,UACR,MAAM,iBACC,aAAa;MAEhC;WASgB;;AACd,YAAI,AAAiB,iCAAU;AAC/B,YAAU,YAAN,KAAK,EAAI,kBAAU,gBAAU;AACkC,QAAnE,cAAS,6CAAiC,uBAAkB,KAAK;AACnD,QAAd,gBAAS,KAAK;AACc,QAA5B,AAAiB,2BAAI;AACN,QAAf,iBAAW;MACb;eAsB4B;;AAEU,QAA/B,AAAS,6BAAS,MAAM,MAAM;MACrC;eAIqB,OAAoB;;AACS,QAAhD,aAAQ,KAAK,GAAa,KAAX,UAAU,EAAV,aAAyB;MAC1C;cAsBoB,OAAkB;AAEU,QAAzC,AAAS,4BAAQ,MAAM,KAAK,EAAE,UAAU;AAC7C,wBAAO,AAEN;AAD2D,UAA1D,WAAM,0CAA4B,MAAM,KAAK,EAAE,UAAU;;MAE7D;;AAMkB;AAEW,UAAtB,AAAS,4BAAQ;AACQ,UAA9B,MAAM,AAAiB;QACzB;;;6BAlIc;MAKW;MAOpB,iBAAW;MAZF;AAEgB,MAAvB,AAAS,6BAAS;IACzB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;UAxNe;;AACb,YAAI,AAAiB,iCAAU;AAC/B;AACgB,UAAd,aAAQ,KAAK;AACc,UAA3B,AAAiB,2BAAI,KAAK;;cACnB;cAAO;AAAd;AAC0B,YAA1B,aAAQ,KAAK,EAAE,UAAU;;;;MAE7B;cAsBmB;;AAEY,QAA7B,AAAS,4BAAQ,MAAM,KAAK;MAC9B;sBAmCgB,QACmB;;;AAEjC,cAAO,AAAO,OAAD,4CAAa,YAAY;MACxC;WAYgB;;AAAU,cAAM,YAAK,KAAK;MAAC;mBA+BA;;AAEG,QAAvC,AAAS,iCAAa,MAAM,UAAU;MAC7C;2BAoBmC;;AAEjC,cAAO,YAAW;MACpB;;AAUkB;;AACc,UAA9B,MAAM,AAAiB;AACgB,UAAvC,wDAAM,OAAyB;AAC/B,gBAAa;QACf;;;AAyBG,QAtBD,gCAA0B,AAWxB,0BAVA,qBACE,AAAiB,+BACjB,QAAC,SAAU,AAAuB,qBAAP,KAAK,qCAC9B,QAAC,aAAc,uDACC,mBACP,KAAK,aACD,SAAS,mGAK1B,QAAC;AACC,cAAyB,YAArB,AAAW,UAAD,YAAc,eAAS,gBAAU;AAC/C;AAC0B,YAAxB,kBAAa,UAAU;AACG,YAA1B,UAAK,AAAW,UAAD;;gBACR;gBAAO;AAAd;AAC0B,cAA1B,aAAQ,KAAK,EAAE,UAAU;;;;qEAGpB;MAEb;;;;;yBAnMW;MAOmC;MAExC,yBAAmB;AATE,oCAAM,YAAY;AACtB,MAArB;IACF;;;;;;;;;;;;;;;;;;;;;;;MAGoB,mBAAQ;YAAG;;;;;;;;0BAqNnB;AAAgB,qCAAM,YAAY;;IAAC","file":"bloc.sound.ddc.js"}');
  // Exports:
  return {
    src__transition: transition,
    bloc: bloc,
    src__bloc_observer: bloc_observer,
    src__bloc: bloc$
  };
}));

//# sourceMappingURL=bloc.sound.ddc.js.map
